## file system 
我们需要做的第一件事是将磁盘分成块（block），我们选择常用的4KB。

为了构建文件系统，需要在这些块中存储什么。首先是用户数据。实际上，任何文件系统中的大多数空间都是（并且应该是）用户数据。我们将用于存放用户数据的磁盘区域称为数据区域（data region）

文件系统必须记录每个文件的信息。该信息是元数据（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息的事情。为了存储这些信息，文件系统通常有一个名为inode的结构，我们将这部分磁盘称为inode表（inode table）

目前为止，我们的文件系统有了数据块（D）和inode（I），但还缺一些东西。你可能已经猜到，还需要某种方法来记录inode或数据块是空闲还是已分配。我们选择一种简单而流行的结构，称为位图（bitmap），一种用于数据区域（数据位图，data bitmap），另一种用于inode表（inode位图，inode bitmap）。位图是一种简单的结构：每个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。

还有一块。我们将它保留给超级块（superblock），在下图中用S表示。超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）。

![qownnotes-media-c16838](../media/qownnotes-media-c16838-1198711678.png)


### 文件组织： inode
在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。

设计inode时，最重要的决定之一是它如何引用数据块的位置。一种简单的方法是在inode中有一个或多个直接指针（磁盘地址）。每个指针指向属于该文件的一个磁盘块。

#### 多级索引 
为了支持更大的文件，文件系统设计者必须在inode中引入不同的结构。一个常见的思路是有一个称为间接指针（indirect  pointer）的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将inode的间接指针设置为指向它。假设一个块是4KB，磁盘地址是4字节，那就增加了1024个指针。文件可以增长到（12 + 1024）×4KB，即4144KB。

你可能希望支持更大的文件。为此，只需添加另一个指向inode的指针：双重间接指针（double  indirect  pointer）。该指针指的是一个包含间接块指针的块，每个间接块都包含指向数据块的指针。因此，双重间接块提供了可能性，允许使用额外的1024×1024个4KB块来增长文件，换言之，支持超过4GB大小的文件。

#### 基于范围
另一种方法是使用范围（extent）而不是指针。范围就是一个磁盘指针加一个长度（以块为单位）。因此，不需要指向文件的每个块的指针，只需要指针和长度来指定文件的磁盘位置。只有一个范围是有局限的，因为分配文件时可能无法找到连续的磁盘可用空间块。因此，基于范围的文件系统通常允许多个范围，从而在文件分配期间给予文件系统更多的自由。

多级索引 基于范围 

这两种方法相比较，基于指针的方法是最灵活的，但是每个文件使用大量元数据（尤其是大文件）。基于范围的方法不够灵活但更紧凑。特别是，如果磁盘上有足够的可用空间并且文件可以连续布局（无论如何，这实际上是所有文件分配策略的目标），基于范围的方法都能正常工作。


> *how does rm work?*
Whenever you delete a file using rm command, the file's data is never deleted. In other words the blocks in the file system containing data is still there.
What happens is when you run the rm command, the system marks the inode belonging to that file as unused and the data blocks of that file also as unused (but not wiped out). However ext3 zeros most of the fields in the inode, when a file is deleted.
This normal marking of unused is done for the speed... Otherwise for deletion it will take some more time. That's why you might have noted deleting even large files are faster (you can recover the data if that data blocks are not overwritten).

### 目录组织
通常，文件系统将目录视为特殊类型的文件。因此，目录有一个inode，位于inode表中的某处（inode表中的inode标记为“目录”的类型字段，而不是“常规文件”）。该目录具有由inode指向的数据块（也可能是间接块）。这些数据块存在于我们的简单文件系统的数据块区域中。


### 文件, 目录 
每个文件都有某种低级名称（low-level name），通常是某种数字。文件的低级名称通常称为inode号（inode  number）。现在，只要假设每个文件都有一个与其关联的inode号。

一个目录，像一个文件一样，也有一个低级名字（即inode号），但是它的内容非常具体：它包含一个 对 pair（用户可读名字，低级名字）的列表。例如，假设存在一个低级别名称为“10”的文件，它的用户可读的名称为“foo”。“foo”所在的目录因此会有条目（“foo”，“10”），将用户可读名称映射到低级名称。目录中的每个条目都指向文件或其他目录。

除了文件，目录，另外一种是 symbolic link

#### hard link /symbolic link

在 Linux 下面的链接文件有两种,一种是类似 Windows 的捷径功能的文件,可以让你快速的链接到目标文件(或目录); 另一种则是通过文件系统的 inode 链接来产生新文件名,而不是产生新文件!这种称为实体链接 (hard link)。 

**hard link**

每个文件都会占用一个 inode ,文件内容由 inode 的记录来指向; 想要读取该文件,必须要经过目录记录的文件名来指向到正确的 inode 号码才能读取。 hard link 只是在某个目录下的 block 多写入一个关连数据而已,既不会增加 inode 也不会耗用 block 数量


也就是说,其实文件名只与目录有关,但是文件内容则与 inode 有关。hard link 只是在某个目录下新增一笔文件名链接到某 inode 号码的关连记录而已。

 如果你将任何一个“文件名”删除,其实 inode 与 block都还是存在的 此时你可以通过另一个“文件名”来读取到正确的文件数据!不论你使用哪个“文件名”来编辑, 最终的结果都会写入到相同的 inode 与 block 中

  *hard link 限制*:
1. 不能跨 Filesystem;
2. 不能 link 目录。

![qownnotes-media-r15850](../../media/1756271750.png)

**symbolic link**

Symbolic link 就是创建一个独立的文件 whose content is a path to the target file. ,而这个文件会让数据的读取指向他 link 的那个文件的文件名!由于只是利用文件来做为指向的动作, 所以,当来源文件被删除之后,symbolic link 的文件会“开不了”, 会“无法打开某文件!”。实际上就是找不到原始“文件名”

两个文件指向不同的 inode 号码,就是两个独立的文件存在, 由Symbolic link 所创建的文件为一个独立的新的文件,所以会占用 inode 与 block 

当你修改 Linux下的 symbolic link 文件时,则更动的其实是“原始文件”
![qownnotes-media-e15850](../../media/949972138.png)


### 读取， 写入
#### 读取文件
我们先假设你只是想打开一个文件（例如/foo/bar，读取它，然后关闭它）。

当你发出一个open("/foo/bar", O_RDONLY)调用时，文件系统首先需要找到文件bar的inode，从而获取关于该文件的一些基本信息（权限信息、文件大小等等）。为此，文件系统必须能够找到inode，但它现在只有完整的路径名。文件系统必须遍历（traverse）路径名，从而找到所需的inode。

所有遍历都从文件系统的根开始，即根目录（root  directory），它就记为/。因此，文件系统的第一次磁盘读取是根目录的inode。但是这个inode在哪里？要找到inode，我们必须知道它的i-number。通常，我们在其父目录中找到文件或目录的i-number。根没有父目录（根据定义）。因此，根的inode号必须是“众所周知的”。在挂载文件系统时，文件系统必须知道它是什么。在大多数UNIX文件系统中，根的inode号为2。因此，要开始该过程，文件系统会读入inode号2的块（第一个inode块）。

一旦inode被读入，文件系统可以在其中查找指向数据块的指针，数据块包含根目录的内容。因此，文件系统将使用这些磁盘上的指针来读取目录，在这个例子中，寻找foo的条目。通过读入一个或多个目录数据块，它将找到foo的条目。一旦找到，文件系统也会找到下一个需要的foo的inode号（假定是44）。

下一步是递归遍历路径名，直到找到所需的inode。

open()的最后一步是将bar的inode读入内存。然后文件系统进行最后的权限检查，在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户。


## 文件系统挂载与卸载
**Note**:
1. 单一文件系统不应该被重复挂载在不同的挂载点(目录)中
2. 单一目录不应该重复挂载多个文件系统
3. 要作为挂载点的目录,理论上应该都是空目录

如果你要用来挂载的目录里面并不是空的,那么挂载了文件系统之后,原目录下的东西就会暂时的消失, 等到新分区被卸载之后,则原本的内容就会再次出来