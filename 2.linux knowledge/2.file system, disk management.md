## file system 
我们需要做的第一件事是将磁盘分成块（block），我们选择常用的4KB。

为了构建文件系统，需要在这些块中存储什么。首先是用户数据。实际上，任何文件系统中的大多数空间都是（并且应该是）用户数据。我们将用于存放用户数据的磁盘区域称为数据区域（data region）

文件系统必须记录每个文件的信息。该信息是元数据（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息的事情。为了存储这些信息，文件系统通常有一个名为inode的结构，我们将这部分磁盘称为inode表（inode table）

目前为止，我们的文件系统有了数据块（D）和inode（I），但还缺一些东西。你可能已经猜到，还需要某种方法来记录inode或数据块是空闲还是已分配。我们选择一种简单而流行的结构，称为位图（bitmap），一种用于数据区域（数据位图，data bitmap），另一种用于inode表（inode位图，inode bitmap）。位图是一种简单的结构：每个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。

还有一块。我们将它保留给超级块（superblock），在下图中用S表示。超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）。

![qownnotes-media-c16838](../media/qownnotes-media-c16838-1198711678.png)


### inode
**inode**:记录文件的属性,一个文件占用一个inode,同时记录此文件的数据所在的 block号码;


> 每个 inode 与 block 都有编号,而每个文件都会占用一个 inode ,inode 内则有文件数据放置的 block 号码。如果能够找到文件的 inode 的话,自然就知道这个文件所放置数据的 block 号码, 也就能够读出该文件的实际数据了。

Ext2 文件系统在格式化的时候基本上是区分为**多个区块群组 (blockgroup)** 的,每个区块群组都有独立的 inode/block/superblock 系统。
![qownnotes-media-Z15850](../../media/2012253410.png)


> *how does rm work?*
Whenever you delete a file using rm command, the file's data is never deleted. In other words the blocks in the file system containing data is still there.
What happens is when you run the rm command, the system marks the inode belonging to that file as unused and the data blocks of that file also as unused (but not wiped out). However ext3 zeros most of the fields in the inode, when a file is deleted.
This normal marking of unused is done for the speed... Otherwise for deletion it will take some more time. That's why you might have noted deleting even large files are faster (you can recover the data if that data blocks are not overwritten).

## 文件, 目录 
每个文件都有某种低级名称（low-level name），通常是某种数字。文件的低级名称通常称为inode号（inode  number）。现在，只要假设每个文件都有一个与其关联的inode号。

一个目录，像一个文件一样，也有一个低级名字（即inode号），但是它的内容非常具体：它包含一个 对 pair（用户可读名字，低级名字）的列表。例如，假设存在一个低级别名称为“10”的文件，它的用户可读的名称为“foo”。“foo”所在的目录因此会有条目（“foo”，“10”），将用户可读名称映射到低级名称。目录中的每个条目都指向文件或其他目录。

除了文件，目录，另外一种是 symbolic link

### hard link /symbolic link

在 Linux 下面的链接文件有两种,一种是类似 Windows 的捷径功能的文件,可以让你快速的链接到目标文件(或目录); 另一种则是通过文件系统的 inode 链接来产生新文件名,而不是产生新文件!这种称为实体链接 (hard link)。 

**hard link**

每个文件都会占用一个 inode ,文件内容由 inode 的记录来指向; 想要读取该文件,必须要经过目录记录的文件名来指向到正确的 inode 号码才能读取。 hard link 只是在某个目录下的 block 多写入一个关连数据而已,既不会增加 inode 也不会耗用 block 数量


也就是说,其实文件名只与目录有关,但是文件内容则与 inode 有关。hard link 只是在某个目录下新增一笔文件名链接到某 inode 号码的关连记录而已。

 如果你将任何一个“文件名”删除,其实 inode 与 block都还是存在的 此时你可以通过另一个“文件名”来读取到正确的文件数据!不论你使用哪个“文件名”来编辑, 最终的结果都会写入到相同的 inode 与 block 中

  *hard link 限制*:
1. 不能跨 Filesystem;
2. 不能 link 目录。

![qownnotes-media-r15850](../../media/1756271750.png)

**symbolic link**

Symbolic link 就是创建一个独立的文件 whose content is a path to the target file. ,而这个文件会让数据的读取指向他 link 的那个文件的文件名!由于只是利用文件来做为指向的动作, 所以,当来源文件被删除之后,symbolic link 的文件会“开不了”, 会“无法打开某文件!”。实际上就是找不到原始“文件名”

两个文件指向不同的 inode 号码,就是两个独立的文件存在, 由Symbolic link 所创建的文件为一个独立的新的文件,所以会占用 inode 与 block 

当你修改 Linux下的 symbolic link 文件时,则更动的其实是“原始文件”
![qownnotes-media-e15850](../../media/949972138.png)



## 文件系统挂载与卸载
**Note**:
1. 单一文件系统不应该被重复挂载在不同的挂载点(目录)中
2. 单一目录不应该重复挂载多个文件系统
3. 要作为挂载点的目录,理论上应该都是空目录

如果你要用来挂载的目录里面并不是空的,那么挂载了文件系统之后,原目录下的东西就会暂时的消失, 等到新分区被卸载之后,则原本的内容就会再次出来